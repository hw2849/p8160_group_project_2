---
title: "logistics"
author: "Xinran Sun"
date: "3/17/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
library(tidyverse)
library(caret)
library(ggcorrplot)
```

## data import and data clean
```{r}
#load the data
breast_dat = read_csv("breast-cancer.csv") %>% 
  janitor::clean_names() %>% 
  select(-33) %>% #drop NA column
  add_row(id = 92751, diagnosis = "B", radius_mean = 7.76, texture_mean = 24.54,
          perimeter_mean = 47.92, area_mean = 181, smoothness_mean = 0.05263,
          compactness_mean = 0.04362, concavity_mean = 0, 
          concave_points_mean = 0, symmetry_mean = 0.1587,
          fractal_dimension_mean = 0.05884, radius_se = 0.3857, 
          texture_se = 1.428, perimeter_se = 2.548, area_se = 19.15,
          smoothness_se = 0.007189, compactness_se = 0.00466, concavity_se = 0,
          concave_points_se = 0, symmetry_se = 0.02676, 
          fractal_dimension_se = 0.002783, radius_worst = 9.456, 
          texture_worst = 30.37, perimeter_worst = 59.16, area_worst = 268.6,
          smoothness_worst = 0.08996, compactness_worst = 0.06444,
          concavity_worst = 0, concave_points_worst = 0, 
          symmetry_worst = 0.2871, fractal_dimension_worst = 0.07039) 
  #add missing row


head(breast_dat, 5)

r = dim(breast_dat)[1] #row number
c = dim(breast_dat)[2] #column number

var_names = names(breast_dat)[-c(1,2)] #variable names
  
standardize = function(col) {
  mean = mean(col)
  sd = sd(col)
  return((col - mean)/sd)
}

stand_df = breast_dat %>% 
  dplyr::select(radius_mean:fractal_dimension_worst) %>% 
  map_df(.x = ., standardize) #standardize

X = stand_df #predictors
y = as.vector(ifelse(breast_dat[,2] == "M", 1, 0))#response
```

## check collinearity

```{r}
corr = stand_df %>% 
  cor()

ggcorrplot(corr, type = "upper")

#X = stand_df %>% 
  #select(radius_mean, texture_mean, smoothness_mean, compactness_mean,
         #symmetry_mean, fractal_dimension_mean, radius_se, texture_se,
         #smoothness_se, concavity_se, symmetry_se)

#corr_new = X %>% cor()
#corr_new

#ggcorrplot(corr_new, type = "upper", lab = TRUE)
```

```{r}
logdata = cbind.data.frame(y, X)
log_model = glm(y ~ ., family = binomial(link = "logit"),data = logdata)
summary(log_model)
```

## Newton-Raphson algorithm

```{r}
## logistic stuff 

logisticstuff = function(dat, betavec){
  
  beta0 = betavec[1]
  betavec = betavec[2:length(betavec)]
  
  u = beta0 + betavec * dat$x
  expu = exp(u)
  loglik = sum(dat$y * (beta0 + betavec * dat$x) - log(1 + exp(beta0 + betavec * dat$x)))
  
  p = vector()
  p = exp(beta0 + betavec * dat$x) / (1 + exp(beta0 + betavec * dat$x))
  
  grad = t(dat$x) %*% sum(dat$y - p) # gradiant
  
  w = p %*% (1 - p)
  hess = -dat$x %*% t(dat$x) %*% w # hessian matrix
  
  return(list(loglik = loglik, grad = grad, hess = hess))
}


## NewtonRaphson
newtonraphson = function(dat, func, start, tol = 10^-10, maxiter = 200){
  i = 0
  curbeta = start
  stuff = func(dat, curbeta)
  res = c(0, stuff$loglik, curbeta)
  prevloglik = -Inf
  while (i < maxiter && abs(stuff$loglik - prevloglik) > tol) {
    i = i + 1
    prevloglik = stuff$loglik
    prev = curbeta
    curbeta = prev - solve(stuff$hess) %*% stuff$grad
    stuff = func(dat, curbeta)
    
    #redirection
    while (is.negative.definite(stuff$hess) == FALSE) {
      stuff$hess = stuff$hess - diag(2)
    }
    
    k = 1 #halfstep
    while (prevloglik > stuff$loglik) {
          halfstep = 1/(2^k)
          curbeta = prev - halfstep * solve(stuff$hess) %*% stuff$grad
          k = k + 1
    }
    
    res = rbind(res, c(i, stuff$loglik, cur))
  }
  return(res)
}


```

